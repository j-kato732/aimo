package proto

import (
	context "context"
	fmt "fmt"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type AimModelORM struct {
	AchievementDifficultyBefore int64
	AchievementLevel            string
	AchievementWeight           int64
	AimItem                     string
	AimNumber                   int64
	CreatedAt                   *time.Time
	Id                          int64
	Period                      string
	UpdatedAt                   *time.Time
	UserId                      int64
}

// TableName overrides the default tablename generated by GORM
func (AimModelORM) TableName() string {
	return "aim_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AimModel) ToORM(ctx context.Context) (AimModelORM, error) {
	to := AimModelORM{}
	var err error
	if prehook, ok := interface{}(m).(AimModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.UserId = m.UserId
	to.AimItem = m.AimItem
	to.AchievementLevel = m.AchievementLevel
	to.AchievementWeight = m.AchievementWeight
	to.AchievementDifficultyBefore = m.AchievementDifficultyBefore
	to.AimNumber = m.AimNumber
	if m.CreatedAt != nil {
		*to.CreatedAt = m.CreatedAt.AsTime()
	}
	if m.UpdatedAt != nil {
		*to.UpdatedAt = m.UpdatedAt.AsTime()
	}
	if posthook, ok := interface{}(m).(AimModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AimModelORM) ToPB(ctx context.Context) (AimModel, error) {
	to := AimModel{}
	var err error
	if prehook, ok := interface{}(m).(AimModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.UserId = m.UserId
	to.AimItem = m.AimItem
	to.AchievementLevel = m.AchievementLevel
	to.AchievementWeight = m.AchievementWeight
	to.AchievementDifficultyBefore = m.AchievementDifficultyBefore
	to.AimNumber = m.AimNumber
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(AimModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AimModel the arg will be the target, the caller the one being converted from

// AimModelBeforeToORM called before default ToORM code
type AimModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *AimModelORM) error
}

// AimModelAfterToORM called after default ToORM code
type AimModelWithAfterToORM interface {
	AfterToORM(context.Context, *AimModelORM) error
}

// AimModelBeforeToPB called before default ToPB code
type AimModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *AimModel) error
}

// AimModelAfterToPB called after default ToPB code
type AimModelWithAfterToPB interface {
	AfterToPB(context.Context, *AimModel) error
}

type AchievementMeanModelORM struct {
	AchievementMean       string
	AchievementMeanNumber int64
	AimNumber             int64
	CreatedAt             *time.Time
	FifthMonth            bool
	FirstMonth            bool
	FourthMonth           bool
	Id                    int64
	Period                string
	SecondMonth           bool
	SixthMonth            bool
	ThirdMonth            bool
	UpdatedAt             *time.Time
	UserId                int64
}

// TableName overrides the default tablename generated by GORM
func (AchievementMeanModelORM) TableName() string {
	return "achievement_mean_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AchievementMeanModel) ToORM(ctx context.Context) (AchievementMeanModelORM, error) {
	to := AchievementMeanModelORM{}
	var err error
	if prehook, ok := interface{}(m).(AchievementMeanModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.UserId = m.UserId
	to.AimNumber = m.AimNumber
	to.AchievementMean = m.AchievementMean
	to.FirstMonth = m.FirstMonth
	to.SecondMonth = m.SecondMonth
	to.ThirdMonth = m.ThirdMonth
	to.FourthMonth = m.FourthMonth
	to.FifthMonth = m.FifthMonth
	to.SixthMonth = m.SixthMonth
	to.AchievementMeanNumber = m.AchievementMeanNumber
	if m.CreatedAt != nil {
		*to.CreatedAt = m.CreatedAt.AsTime()
	}
	if m.UpdatedAt != nil {
		*to.UpdatedAt = m.UpdatedAt.AsTime()
	}
	if posthook, ok := interface{}(m).(AchievementMeanModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AchievementMeanModelORM) ToPB(ctx context.Context) (AchievementMeanModel, error) {
	to := AchievementMeanModel{}
	var err error
	if prehook, ok := interface{}(m).(AchievementMeanModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.UserId = m.UserId
	to.AimNumber = m.AimNumber
	to.AchievementMean = m.AchievementMean
	to.FirstMonth = m.FirstMonth
	to.SecondMonth = m.SecondMonth
	to.ThirdMonth = m.ThirdMonth
	to.FourthMonth = m.FourthMonth
	to.FifthMonth = m.FifthMonth
	to.SixthMonth = m.SixthMonth
	to.AchievementMeanNumber = m.AchievementMeanNumber
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(AchievementMeanModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AchievementMeanModel the arg will be the target, the caller the one being converted from

// AchievementMeanModelBeforeToORM called before default ToORM code
type AchievementMeanModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *AchievementMeanModelORM) error
}

// AchievementMeanModelAfterToORM called after default ToORM code
type AchievementMeanModelWithAfterToORM interface {
	AfterToORM(context.Context, *AchievementMeanModelORM) error
}

// AchievementMeanModelBeforeToPB called before default ToPB code
type AchievementMeanModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *AchievementMeanModel) error
}

// AchievementMeanModelAfterToPB called after default ToPB code
type AchievementMeanModelWithAfterToPB interface {
	AfterToPB(context.Context, *AchievementMeanModel) error
}

// DefaultCreateAimModel executes a basic gorm create call
func DefaultCreateAimModel(ctx context.Context, in *AimModel, db *gorm.DB) (*AimModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AimModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAimModel(ctx context.Context, in *AimModel, db *gorm.DB) (*AimModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AimModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AimModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AimModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AimModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAimModel(ctx context.Context, in *AimModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AimModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AimModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAimModelSet(ctx context.Context, in []*AimModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AimModelORM{})).(AimModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AimModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AimModelORM{})).(AimModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AimModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AimModel, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AimModel, *gorm.DB) error
}

// DefaultStrictUpdateAimModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAimModel(ctx context.Context, in *AimModel, db *gorm.DB) (*AimModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAimModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AimModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AimModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAimModel executes a basic gorm update call with patch behavior
func DefaultPatchAimModel(ctx context.Context, in *AimModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*AimModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AimModel
	var err error
	if hook, ok := interface{}(&pbObj).(AimModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAimModel(ctx, &AimModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AimModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAimModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AimModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAimModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AimModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AimModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AimModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AimModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AimModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AimModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AimModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AimModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AimModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAimModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetAimModel(ctx context.Context, objects []*AimModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AimModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AimModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAimModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAimModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAimModel(ctx context.Context, patchee *AimModel, patcher *AimModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AimModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Period" {
			patchee.Period = patcher.Period
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"AimItem" {
			patchee.AimItem = patcher.AimItem
			continue
		}
		if f == prefix+"AchievementLevel" {
			patchee.AchievementLevel = patcher.AchievementLevel
			continue
		}
		if f == prefix+"AchievementWeight" {
			patchee.AchievementWeight = patcher.AchievementWeight
			continue
		}
		if f == prefix+"AchievementDifficultyBefore" {
			patchee.AchievementDifficultyBefore = patcher.AchievementDifficultyBefore
			continue
		}
		if f == prefix+"AimNumber" {
			patchee.AimNumber = patcher.AimNumber
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAimModel executes a gorm list call
func DefaultListAimModel(ctx context.Context, db *gorm.DB) ([]*AimModel, error) {
	in := AimModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AimModelORM{}, &AimModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AimModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AimModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AimModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AimModelORM) error
}

// DefaultCreateAchievementMeanModel executes a basic gorm create call
func DefaultCreateAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, db *gorm.DB) (*AchievementMeanModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AchievementMeanModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, db *gorm.DB) (*AchievementMeanModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AchievementMeanModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AchievementMeanModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AchievementMeanModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AchievementMeanModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AchievementMeanModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AchievementMeanModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAchievementMeanModelSet(ctx context.Context, in []*AchievementMeanModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AchievementMeanModelORM{})).(AchievementMeanModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AchievementMeanModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AchievementMeanModelORM{})).(AchievementMeanModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AchievementMeanModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AchievementMeanModel, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AchievementMeanModel, *gorm.DB) error
}

// DefaultStrictUpdateAchievementMeanModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, db *gorm.DB) (*AchievementMeanModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAchievementMeanModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AchievementMeanModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AchievementMeanModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAchievementMeanModel executes a basic gorm update call with patch behavior
func DefaultPatchAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*AchievementMeanModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AchievementMeanModel
	var err error
	if hook, ok := interface{}(&pbObj).(AchievementMeanModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAchievementMeanModel(ctx, &AchievementMeanModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AchievementMeanModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAchievementMeanModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AchievementMeanModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAchievementMeanModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AchievementMeanModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AchievementMeanModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AchievementMeanModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AchievementMeanModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AchievementMeanModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AchievementMeanModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAchievementMeanModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetAchievementMeanModel(ctx context.Context, objects []*AchievementMeanModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AchievementMeanModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AchievementMeanModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAchievementMeanModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAchievementMeanModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAchievementMeanModel(ctx context.Context, patchee *AchievementMeanModel, patcher *AchievementMeanModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AchievementMeanModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Period" {
			patchee.Period = patcher.Period
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"AimNumber" {
			patchee.AimNumber = patcher.AimNumber
			continue
		}
		if f == prefix+"AchievementMean" {
			patchee.AchievementMean = patcher.AchievementMean
			continue
		}
		if f == prefix+"FirstMonth" {
			patchee.FirstMonth = patcher.FirstMonth
			continue
		}
		if f == prefix+"SecondMonth" {
			patchee.SecondMonth = patcher.SecondMonth
			continue
		}
		if f == prefix+"ThirdMonth" {
			patchee.ThirdMonth = patcher.ThirdMonth
			continue
		}
		if f == prefix+"FourthMonth" {
			patchee.FourthMonth = patcher.FourthMonth
			continue
		}
		if f == prefix+"FifthMonth" {
			patchee.FifthMonth = patcher.FifthMonth
			continue
		}
		if f == prefix+"SixthMonth" {
			patchee.SixthMonth = patcher.SixthMonth
			continue
		}
		if f == prefix+"AchievementMeanNumber" {
			patchee.AchievementMeanNumber = patcher.AchievementMeanNumber
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAchievementMeanModel executes a gorm list call
func DefaultListAchievementMeanModel(ctx context.Context, db *gorm.DB) ([]*AchievementMeanModel, error) {
	in := AchievementMeanModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AchievementMeanModelORM{}, &AchievementMeanModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AchievementMeanModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AchievementMeanModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AchievementMeanModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AchievementMeanModelORM) error
}
