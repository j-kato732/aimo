package proto

import (
	context "context"
	fmt "fmt"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type AimModelORM struct {
	AchievementDifficultyBefore int64
	AchievementLevel            string
	AchievementWeight           int64
	AimItem                     string
	AimNumber                   int64
	CreatedAt                   *time.Time
	Id                          int64
	Period                      string
	UpdatedAt                   *time.Time
	UserId                      int64
}

// TableName overrides the default tablename generated by GORM
func (AimModelORM) TableName() string {
	return "aim_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AimModel) ToORM(ctx context.Context) (AimModelORM, error) {
	to := AimModelORM{}
	var err error
	if prehook, ok := interface{}(m).(AimModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.UserId = m.UserId
	to.AimItem = m.AimItem
	to.AchievementLevel = m.AchievementLevel
	to.AchievementWeight = m.AchievementWeight
	to.AchievementDifficultyBefore = m.AchievementDifficultyBefore
	to.AimNumber = m.AimNumber
	if m.CreatedAt != nil {
		*to.CreatedAt = m.CreatedAt.AsTime()
	}
	if m.UpdatedAt != nil {
		*to.UpdatedAt = m.UpdatedAt.AsTime()
	}
	if posthook, ok := interface{}(m).(AimModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AimModelORM) ToPB(ctx context.Context) (AimModel, error) {
	to := AimModel{}
	var err error
	if prehook, ok := interface{}(m).(AimModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.UserId = m.UserId
	to.AimItem = m.AimItem
	to.AchievementLevel = m.AchievementLevel
	to.AchievementWeight = m.AchievementWeight
	to.AchievementDifficultyBefore = m.AchievementDifficultyBefore
	to.AimNumber = m.AimNumber
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(AimModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AimModel the arg will be the target, the caller the one being converted from

// AimModelBeforeToORM called before default ToORM code
type AimModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *AimModelORM) error
}

// AimModelAfterToORM called after default ToORM code
type AimModelWithAfterToORM interface {
	AfterToORM(context.Context, *AimModelORM) error
}

// AimModelBeforeToPB called before default ToPB code
type AimModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *AimModel) error
}

// AimModelAfterToPB called after default ToPB code
type AimModelWithAfterToPB interface {
	AfterToPB(context.Context, *AimModel) error
}

type AchievementMeanModelORM struct {
	AchievementMean       string
	AchievementMeanNumber int64
	AimNumber             int64
	CreatedAt             *time.Time
	FifthMonth            bool
	FirstMonth            bool
	FourthMonth           bool
	Id                    int64
	Period                string
	SecondMonth           bool
	SixthMonth            bool
	ThirdMonth            bool
	UpdatedAt             *time.Time
	UserId                int64
}

// TableName overrides the default tablename generated by GORM
func (AchievementMeanModelORM) TableName() string {
	return "achievement_mean_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AchievementMeanModel) ToORM(ctx context.Context) (AchievementMeanModelORM, error) {
	to := AchievementMeanModelORM{}
	var err error
	if prehook, ok := interface{}(m).(AchievementMeanModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.UserId = m.UserId
	to.AimNumber = m.AimNumber
	to.AchievementMean = m.AchievementMean
	to.FirstMonth = m.FirstMonth
	to.SecondMonth = m.SecondMonth
	to.ThirdMonth = m.ThirdMonth
	to.FourthMonth = m.FourthMonth
	to.FifthMonth = m.FifthMonth
	to.SixthMonth = m.SixthMonth
	to.AchievementMeanNumber = m.AchievementMeanNumber
	if m.CreatedAt != nil {
		*to.CreatedAt = m.CreatedAt.AsTime()
	}
	if m.UpdatedAt != nil {
		*to.UpdatedAt = m.UpdatedAt.AsTime()
	}
	if posthook, ok := interface{}(m).(AchievementMeanModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AchievementMeanModelORM) ToPB(ctx context.Context) (AchievementMeanModel, error) {
	to := AchievementMeanModel{}
	var err error
	if prehook, ok := interface{}(m).(AchievementMeanModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.UserId = m.UserId
	to.AimNumber = m.AimNumber
	to.AchievementMean = m.AchievementMean
	to.FirstMonth = m.FirstMonth
	to.SecondMonth = m.SecondMonth
	to.ThirdMonth = m.ThirdMonth
	to.FourthMonth = m.FourthMonth
	to.FifthMonth = m.FifthMonth
	to.SixthMonth = m.SixthMonth
	to.AchievementMeanNumber = m.AchievementMeanNumber
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(AchievementMeanModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AchievementMeanModel the arg will be the target, the caller the one being converted from

// AchievementMeanModelBeforeToORM called before default ToORM code
type AchievementMeanModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *AchievementMeanModelORM) error
}

// AchievementMeanModelAfterToORM called after default ToORM code
type AchievementMeanModelWithAfterToORM interface {
	AfterToORM(context.Context, *AchievementMeanModelORM) error
}

// AchievementMeanModelBeforeToPB called before default ToPB code
type AchievementMeanModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *AchievementMeanModel) error
}

// AchievementMeanModelAfterToPB called after default ToPB code
type AchievementMeanModelWithAfterToPB interface {
	AfterToPB(context.Context, *AchievementMeanModel) error
}

type PersonalEvaModelORM struct {
	AchievementDifficulty int64
	AchievementRate       int64
	AimId                 int64
	Id                    int64
	PersonalEvaluation    string
}

// TableName overrides the default tablename generated by GORM
func (PersonalEvaModelORM) TableName() string {
	return "personal_eva_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PersonalEvaModel) ToORM(ctx context.Context) (PersonalEvaModelORM, error) {
	to := PersonalEvaModelORM{}
	var err error
	if prehook, ok := interface{}(m).(PersonalEvaModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AimId = m.AimId
	to.PersonalEvaluation = m.PersonalEvaluation
	to.AchievementRate = m.AchievementRate
	to.AchievementDifficulty = m.AchievementDifficulty
	if posthook, ok := interface{}(m).(PersonalEvaModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PersonalEvaModelORM) ToPB(ctx context.Context) (PersonalEvaModel, error) {
	to := PersonalEvaModel{}
	var err error
	if prehook, ok := interface{}(m).(PersonalEvaModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AimId = m.AimId
	to.PersonalEvaluation = m.PersonalEvaluation
	to.AchievementRate = m.AchievementRate
	to.AchievementDifficulty = m.AchievementDifficulty
	if posthook, ok := interface{}(m).(PersonalEvaModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PersonalEvaModel the arg will be the target, the caller the one being converted from

// PersonalEvaModelBeforeToORM called before default ToORM code
type PersonalEvaModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *PersonalEvaModelORM) error
}

// PersonalEvaModelAfterToORM called after default ToORM code
type PersonalEvaModelWithAfterToORM interface {
	AfterToORM(context.Context, *PersonalEvaModelORM) error
}

// PersonalEvaModelBeforeToPB called before default ToPB code
type PersonalEvaModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *PersonalEvaModel) error
}

// PersonalEvaModelAfterToPB called after default ToPB code
type PersonalEvaModelWithAfterToPB interface {
	AfterToPB(context.Context, *PersonalEvaModel) error
}

type EvaluationBeforeModelORM struct {
	AimId           int64
	Comment         string
	CommentUserId   int64
	EvaluatorNumber int64
	Id              int64
}

// TableName overrides the default tablename generated by GORM
func (EvaluationBeforeModelORM) TableName() string {
	return "evaluation_before_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *EvaluationBeforeModel) ToORM(ctx context.Context) (EvaluationBeforeModelORM, error) {
	to := EvaluationBeforeModelORM{}
	var err error
	if prehook, ok := interface{}(m).(EvaluationBeforeModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AimId = m.AimId
	to.Comment = m.Comment
	to.EvaluatorNumber = m.EvaluatorNumber
	to.CommentUserId = m.CommentUserId
	if posthook, ok := interface{}(m).(EvaluationBeforeModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EvaluationBeforeModelORM) ToPB(ctx context.Context) (EvaluationBeforeModel, error) {
	to := EvaluationBeforeModel{}
	var err error
	if prehook, ok := interface{}(m).(EvaluationBeforeModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AimId = m.AimId
	to.Comment = m.Comment
	to.EvaluatorNumber = m.EvaluatorNumber
	to.CommentUserId = m.CommentUserId
	if posthook, ok := interface{}(m).(EvaluationBeforeModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type EvaluationBeforeModel the arg will be the target, the caller the one being converted from

// EvaluationBeforeModelBeforeToORM called before default ToORM code
type EvaluationBeforeModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *EvaluationBeforeModelORM) error
}

// EvaluationBeforeModelAfterToORM called after default ToORM code
type EvaluationBeforeModelWithAfterToORM interface {
	AfterToORM(context.Context, *EvaluationBeforeModelORM) error
}

// EvaluationBeforeModelBeforeToPB called before default ToPB code
type EvaluationBeforeModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *EvaluationBeforeModel) error
}

// EvaluationBeforeModelAfterToPB called after default ToPB code
type EvaluationBeforeModelWithAfterToPB interface {
	AfterToPB(context.Context, *EvaluationBeforeModel) error
}

type EvaluationModelORM struct {
	AchievementDifficulty int64
	AchievementRate       int64
	AimId                 int64
	Comment               string
	EvaluatorNumber       int64
	EvaluatorUserId       int64
	Id                    int64
}

// TableName overrides the default tablename generated by GORM
func (EvaluationModelORM) TableName() string {
	return "evaluation_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *EvaluationModel) ToORM(ctx context.Context) (EvaluationModelORM, error) {
	to := EvaluationModelORM{}
	var err error
	if prehook, ok := interface{}(m).(EvaluationModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AimId = m.AimId
	to.Comment = m.Comment
	to.AchievementRate = m.AchievementRate
	to.AchievementDifficulty = m.AchievementDifficulty
	to.EvaluatorNumber = m.EvaluatorNumber
	to.EvaluatorUserId = m.EvaluatorUserId
	if posthook, ok := interface{}(m).(EvaluationModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EvaluationModelORM) ToPB(ctx context.Context) (EvaluationModel, error) {
	to := EvaluationModel{}
	var err error
	if prehook, ok := interface{}(m).(EvaluationModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AimId = m.AimId
	to.Comment = m.Comment
	to.AchievementRate = m.AchievementRate
	to.AchievementDifficulty = m.AchievementDifficulty
	to.EvaluatorNumber = m.EvaluatorNumber
	to.EvaluatorUserId = m.EvaluatorUserId
	if posthook, ok := interface{}(m).(EvaluationModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type EvaluationModel the arg will be the target, the caller the one being converted from

// EvaluationModelBeforeToORM called before default ToORM code
type EvaluationModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *EvaluationModelORM) error
}

// EvaluationModelAfterToORM called after default ToORM code
type EvaluationModelWithAfterToORM interface {
	AfterToORM(context.Context, *EvaluationModelORM) error
}

// EvaluationModelBeforeToPB called before default ToPB code
type EvaluationModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *EvaluationModel) error
}

// EvaluationModelAfterToPB called after default ToPB code
type EvaluationModelWithAfterToPB interface {
	AfterToPB(context.Context, *EvaluationModel) error
}

type ComprehensiveCommentModelORM struct {
	CommentUserId        int64
	ComprehensiveComment string
	Id                   int64
	Period               string
	UserId               int64
}

// TableName overrides the default tablename generated by GORM
func (ComprehensiveCommentModelORM) TableName() string {
	return "comprehensive_comment_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ComprehensiveCommentModel) ToORM(ctx context.Context) (ComprehensiveCommentModelORM, error) {
	to := ComprehensiveCommentModelORM{}
	var err error
	if prehook, ok := interface{}(m).(ComprehensiveCommentModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Period = m.Period
	to.ComprehensiveComment = m.ComprehensiveComment
	to.CommentUserId = m.CommentUserId
	if posthook, ok := interface{}(m).(ComprehensiveCommentModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ComprehensiveCommentModelORM) ToPB(ctx context.Context) (ComprehensiveCommentModel, error) {
	to := ComprehensiveCommentModel{}
	var err error
	if prehook, ok := interface{}(m).(ComprehensiveCommentModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Period = m.Period
	to.ComprehensiveComment = m.ComprehensiveComment
	to.CommentUserId = m.CommentUserId
	if posthook, ok := interface{}(m).(ComprehensiveCommentModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ComprehensiveCommentModel the arg will be the target, the caller the one being converted from

// ComprehensiveCommentModelBeforeToORM called before default ToORM code
type ComprehensiveCommentModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *ComprehensiveCommentModelORM) error
}

// ComprehensiveCommentModelAfterToORM called after default ToORM code
type ComprehensiveCommentModelWithAfterToORM interface {
	AfterToORM(context.Context, *ComprehensiveCommentModelORM) error
}

// ComprehensiveCommentModelBeforeToPB called before default ToPB code
type ComprehensiveCommentModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *ComprehensiveCommentModel) error
}

// ComprehensiveCommentModelAfterToPB called after default ToPB code
type ComprehensiveCommentModelWithAfterToPB interface {
	AfterToPB(context.Context, *ComprehensiveCommentModel) error
}

// DefaultCreateAimModel executes a basic gorm create call
func DefaultCreateAimModel(ctx context.Context, in *AimModel, db *gorm.DB) (*AimModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AimModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAimModel(ctx context.Context, in *AimModel, db *gorm.DB) (*AimModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AimModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AimModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AimModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AimModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAimModel(ctx context.Context, in *AimModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AimModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AimModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAimModelSet(ctx context.Context, in []*AimModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AimModelORM{})).(AimModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AimModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AimModelORM{})).(AimModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AimModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AimModel, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AimModel, *gorm.DB) error
}

// DefaultStrictUpdateAimModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAimModel(ctx context.Context, in *AimModel, db *gorm.DB) (*AimModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAimModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AimModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AimModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAimModel executes a basic gorm update call with patch behavior
func DefaultPatchAimModel(ctx context.Context, in *AimModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*AimModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AimModel
	var err error
	if hook, ok := interface{}(&pbObj).(AimModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAimModel(ctx, &AimModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AimModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAimModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AimModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAimModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AimModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AimModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AimModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AimModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AimModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AimModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AimModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AimModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AimModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAimModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetAimModel(ctx context.Context, objects []*AimModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AimModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AimModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAimModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAimModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAimModel(ctx context.Context, patchee *AimModel, patcher *AimModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AimModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Period" {
			patchee.Period = patcher.Period
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"AimItem" {
			patchee.AimItem = patcher.AimItem
			continue
		}
		if f == prefix+"AchievementLevel" {
			patchee.AchievementLevel = patcher.AchievementLevel
			continue
		}
		if f == prefix+"AchievementWeight" {
			patchee.AchievementWeight = patcher.AchievementWeight
			continue
		}
		if f == prefix+"AchievementDifficultyBefore" {
			patchee.AchievementDifficultyBefore = patcher.AchievementDifficultyBefore
			continue
		}
		if f == prefix+"AimNumber" {
			patchee.AimNumber = patcher.AimNumber
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAimModel executes a gorm list call
func DefaultListAimModel(ctx context.Context, db *gorm.DB) ([]*AimModel, error) {
	in := AimModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AimModelORM{}, &AimModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AimModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AimModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AimModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AimModelORM) error
}

// DefaultCreateAchievementMeanModel executes a basic gorm create call
func DefaultCreateAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, db *gorm.DB) (*AchievementMeanModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AchievementMeanModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, db *gorm.DB) (*AchievementMeanModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AchievementMeanModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AchievementMeanModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AchievementMeanModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AchievementMeanModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AchievementMeanModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AchievementMeanModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAchievementMeanModelSet(ctx context.Context, in []*AchievementMeanModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AchievementMeanModelORM{})).(AchievementMeanModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AchievementMeanModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AchievementMeanModelORM{})).(AchievementMeanModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AchievementMeanModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AchievementMeanModel, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AchievementMeanModel, *gorm.DB) error
}

// DefaultStrictUpdateAchievementMeanModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, db *gorm.DB) (*AchievementMeanModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAchievementMeanModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AchievementMeanModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AchievementMeanModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAchievementMeanModel executes a basic gorm update call with patch behavior
func DefaultPatchAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*AchievementMeanModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AchievementMeanModel
	var err error
	if hook, ok := interface{}(&pbObj).(AchievementMeanModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAchievementMeanModel(ctx, &AchievementMeanModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AchievementMeanModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAchievementMeanModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AchievementMeanModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAchievementMeanModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AchievementMeanModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AchievementMeanModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AchievementMeanModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AchievementMeanModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AchievementMeanModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AchievementMeanModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAchievementMeanModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetAchievementMeanModel(ctx context.Context, objects []*AchievementMeanModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AchievementMeanModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AchievementMeanModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAchievementMeanModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAchievementMeanModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAchievementMeanModel(ctx context.Context, patchee *AchievementMeanModel, patcher *AchievementMeanModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AchievementMeanModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Period" {
			patchee.Period = patcher.Period
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"AimNumber" {
			patchee.AimNumber = patcher.AimNumber
			continue
		}
		if f == prefix+"AchievementMean" {
			patchee.AchievementMean = patcher.AchievementMean
			continue
		}
		if f == prefix+"FirstMonth" {
			patchee.FirstMonth = patcher.FirstMonth
			continue
		}
		if f == prefix+"SecondMonth" {
			patchee.SecondMonth = patcher.SecondMonth
			continue
		}
		if f == prefix+"ThirdMonth" {
			patchee.ThirdMonth = patcher.ThirdMonth
			continue
		}
		if f == prefix+"FourthMonth" {
			patchee.FourthMonth = patcher.FourthMonth
			continue
		}
		if f == prefix+"FifthMonth" {
			patchee.FifthMonth = patcher.FifthMonth
			continue
		}
		if f == prefix+"SixthMonth" {
			patchee.SixthMonth = patcher.SixthMonth
			continue
		}
		if f == prefix+"AchievementMeanNumber" {
			patchee.AchievementMeanNumber = patcher.AchievementMeanNumber
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAchievementMeanModel executes a gorm list call
func DefaultListAchievementMeanModel(ctx context.Context, db *gorm.DB) ([]*AchievementMeanModel, error) {
	in := AchievementMeanModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AchievementMeanModelORM{}, &AchievementMeanModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AchievementMeanModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AchievementMeanModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AchievementMeanModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AchievementMeanModelORM) error
}

// DefaultCreatePersonalEvaModel executes a basic gorm create call
func DefaultCreatePersonalEvaModel(ctx context.Context, in *PersonalEvaModel, db *gorm.DB) (*PersonalEvaModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PersonalEvaModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPersonalEvaModel(ctx context.Context, in *PersonalEvaModel, db *gorm.DB) (*PersonalEvaModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PersonalEvaModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PersonalEvaModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PersonalEvaModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PersonalEvaModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePersonalEvaModel(ctx context.Context, in *PersonalEvaModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PersonalEvaModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PersonalEvaModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePersonalEvaModelSet(ctx context.Context, in []*PersonalEvaModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PersonalEvaModelORM{})).(PersonalEvaModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PersonalEvaModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PersonalEvaModelORM{})).(PersonalEvaModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PersonalEvaModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PersonalEvaModel, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PersonalEvaModel, *gorm.DB) error
}

// DefaultStrictUpdatePersonalEvaModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePersonalEvaModel(ctx context.Context, in *PersonalEvaModel, db *gorm.DB) (*PersonalEvaModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePersonalEvaModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PersonalEvaModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PersonalEvaModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPersonalEvaModel executes a basic gorm update call with patch behavior
func DefaultPatchPersonalEvaModel(ctx context.Context, in *PersonalEvaModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*PersonalEvaModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PersonalEvaModel
	var err error
	if hook, ok := interface{}(&pbObj).(PersonalEvaModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPersonalEvaModel(ctx, &PersonalEvaModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PersonalEvaModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPersonalEvaModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PersonalEvaModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePersonalEvaModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PersonalEvaModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PersonalEvaModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PersonalEvaModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PersonalEvaModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PersonalEvaModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PersonalEvaModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPersonalEvaModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetPersonalEvaModel(ctx context.Context, objects []*PersonalEvaModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PersonalEvaModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PersonalEvaModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPersonalEvaModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPersonalEvaModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPersonalEvaModel(ctx context.Context, patchee *PersonalEvaModel, patcher *PersonalEvaModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PersonalEvaModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AimId" {
			patchee.AimId = patcher.AimId
			continue
		}
		if f == prefix+"PersonalEvaluation" {
			patchee.PersonalEvaluation = patcher.PersonalEvaluation
			continue
		}
		if f == prefix+"AchievementRate" {
			patchee.AchievementRate = patcher.AchievementRate
			continue
		}
		if f == prefix+"AchievementDifficulty" {
			patchee.AchievementDifficulty = patcher.AchievementDifficulty
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPersonalEvaModel executes a gorm list call
func DefaultListPersonalEvaModel(ctx context.Context, db *gorm.DB) ([]*PersonalEvaModel, error) {
	in := PersonalEvaModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PersonalEvaModelORM{}, &PersonalEvaModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PersonalEvaModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PersonalEvaModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PersonalEvaModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PersonalEvaModelORM) error
}

// DefaultCreateEvaluationBeforeModel executes a basic gorm create call
func DefaultCreateEvaluationBeforeModel(ctx context.Context, in *EvaluationBeforeModel, db *gorm.DB) (*EvaluationBeforeModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EvaluationBeforeModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEvaluationBeforeModel(ctx context.Context, in *EvaluationBeforeModel, db *gorm.DB) (*EvaluationBeforeModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &EvaluationBeforeModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EvaluationBeforeModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EvaluationBeforeModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EvaluationBeforeModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEvaluationBeforeModel(ctx context.Context, in *EvaluationBeforeModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EvaluationBeforeModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EvaluationBeforeModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEvaluationBeforeModelSet(ctx context.Context, in []*EvaluationBeforeModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EvaluationBeforeModelORM{})).(EvaluationBeforeModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EvaluationBeforeModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EvaluationBeforeModelORM{})).(EvaluationBeforeModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EvaluationBeforeModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*EvaluationBeforeModel, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*EvaluationBeforeModel, *gorm.DB) error
}

// DefaultStrictUpdateEvaluationBeforeModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEvaluationBeforeModel(ctx context.Context, in *EvaluationBeforeModel, db *gorm.DB) (*EvaluationBeforeModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEvaluationBeforeModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EvaluationBeforeModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EvaluationBeforeModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEvaluationBeforeModel executes a basic gorm update call with patch behavior
func DefaultPatchEvaluationBeforeModel(ctx context.Context, in *EvaluationBeforeModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*EvaluationBeforeModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj EvaluationBeforeModel
	var err error
	if hook, ok := interface{}(&pbObj).(EvaluationBeforeModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEvaluationBeforeModel(ctx, &EvaluationBeforeModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EvaluationBeforeModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEvaluationBeforeModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EvaluationBeforeModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEvaluationBeforeModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EvaluationBeforeModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EvaluationBeforeModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *EvaluationBeforeModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *EvaluationBeforeModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *EvaluationBeforeModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *EvaluationBeforeModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEvaluationBeforeModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetEvaluationBeforeModel(ctx context.Context, objects []*EvaluationBeforeModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*EvaluationBeforeModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*EvaluationBeforeModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEvaluationBeforeModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEvaluationBeforeModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEvaluationBeforeModel(ctx context.Context, patchee *EvaluationBeforeModel, patcher *EvaluationBeforeModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*EvaluationBeforeModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AimId" {
			patchee.AimId = patcher.AimId
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"EvaluatorNumber" {
			patchee.EvaluatorNumber = patcher.EvaluatorNumber
			continue
		}
		if f == prefix+"CommentUserId" {
			patchee.CommentUserId = patcher.CommentUserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEvaluationBeforeModel executes a gorm list call
func DefaultListEvaluationBeforeModel(ctx context.Context, db *gorm.DB) ([]*EvaluationBeforeModel, error) {
	in := EvaluationBeforeModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &EvaluationBeforeModelORM{}, &EvaluationBeforeModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EvaluationBeforeModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*EvaluationBeforeModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EvaluationBeforeModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EvaluationBeforeModelORM) error
}

// DefaultCreateEvaluationModel executes a basic gorm create call
func DefaultCreateEvaluationModel(ctx context.Context, in *EvaluationModel, db *gorm.DB) (*EvaluationModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EvaluationModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEvaluationModel(ctx context.Context, in *EvaluationModel, db *gorm.DB) (*EvaluationModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &EvaluationModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EvaluationModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EvaluationModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EvaluationModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEvaluationModel(ctx context.Context, in *EvaluationModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EvaluationModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EvaluationModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEvaluationModelSet(ctx context.Context, in []*EvaluationModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EvaluationModelORM{})).(EvaluationModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EvaluationModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EvaluationModelORM{})).(EvaluationModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EvaluationModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*EvaluationModel, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*EvaluationModel, *gorm.DB) error
}

// DefaultStrictUpdateEvaluationModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEvaluationModel(ctx context.Context, in *EvaluationModel, db *gorm.DB) (*EvaluationModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEvaluationModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EvaluationModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EvaluationModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEvaluationModel executes a basic gorm update call with patch behavior
func DefaultPatchEvaluationModel(ctx context.Context, in *EvaluationModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*EvaluationModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj EvaluationModel
	var err error
	if hook, ok := interface{}(&pbObj).(EvaluationModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEvaluationModel(ctx, &EvaluationModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EvaluationModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEvaluationModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EvaluationModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEvaluationModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EvaluationModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EvaluationModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *EvaluationModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *EvaluationModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *EvaluationModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *EvaluationModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEvaluationModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetEvaluationModel(ctx context.Context, objects []*EvaluationModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*EvaluationModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*EvaluationModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEvaluationModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEvaluationModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEvaluationModel(ctx context.Context, patchee *EvaluationModel, patcher *EvaluationModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*EvaluationModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AimId" {
			patchee.AimId = patcher.AimId
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"AchievementRate" {
			patchee.AchievementRate = patcher.AchievementRate
			continue
		}
		if f == prefix+"AchievementDifficulty" {
			patchee.AchievementDifficulty = patcher.AchievementDifficulty
			continue
		}
		if f == prefix+"EvaluatorNumber" {
			patchee.EvaluatorNumber = patcher.EvaluatorNumber
			continue
		}
		if f == prefix+"EvaluatorUserId" {
			patchee.EvaluatorUserId = patcher.EvaluatorUserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEvaluationModel executes a gorm list call
func DefaultListEvaluationModel(ctx context.Context, db *gorm.DB) ([]*EvaluationModel, error) {
	in := EvaluationModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &EvaluationModelORM{}, &EvaluationModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EvaluationModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*EvaluationModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EvaluationModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EvaluationModelORM) error
}

// DefaultCreateComprehensiveCommentModel executes a basic gorm create call
func DefaultCreateComprehensiveCommentModel(ctx context.Context, in *ComprehensiveCommentModel, db *gorm.DB) (*ComprehensiveCommentModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ComprehensiveCommentModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadComprehensiveCommentModel(ctx context.Context, in *ComprehensiveCommentModel, db *gorm.DB) (*ComprehensiveCommentModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ComprehensiveCommentModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ComprehensiveCommentModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ComprehensiveCommentModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ComprehensiveCommentModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteComprehensiveCommentModel(ctx context.Context, in *ComprehensiveCommentModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ComprehensiveCommentModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ComprehensiveCommentModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteComprehensiveCommentModelSet(ctx context.Context, in []*ComprehensiveCommentModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ComprehensiveCommentModelORM{})).(ComprehensiveCommentModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ComprehensiveCommentModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ComprehensiveCommentModelORM{})).(ComprehensiveCommentModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ComprehensiveCommentModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ComprehensiveCommentModel, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ComprehensiveCommentModel, *gorm.DB) error
}

// DefaultStrictUpdateComprehensiveCommentModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateComprehensiveCommentModel(ctx context.Context, in *ComprehensiveCommentModel, db *gorm.DB) (*ComprehensiveCommentModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateComprehensiveCommentModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ComprehensiveCommentModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ComprehensiveCommentModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchComprehensiveCommentModel executes a basic gorm update call with patch behavior
func DefaultPatchComprehensiveCommentModel(ctx context.Context, in *ComprehensiveCommentModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*ComprehensiveCommentModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ComprehensiveCommentModel
	var err error
	if hook, ok := interface{}(&pbObj).(ComprehensiveCommentModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadComprehensiveCommentModel(ctx, &ComprehensiveCommentModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ComprehensiveCommentModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskComprehensiveCommentModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ComprehensiveCommentModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateComprehensiveCommentModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ComprehensiveCommentModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ComprehensiveCommentModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ComprehensiveCommentModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ComprehensiveCommentModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ComprehensiveCommentModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ComprehensiveCommentModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetComprehensiveCommentModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetComprehensiveCommentModel(ctx context.Context, objects []*ComprehensiveCommentModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ComprehensiveCommentModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ComprehensiveCommentModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchComprehensiveCommentModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskComprehensiveCommentModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskComprehensiveCommentModel(ctx context.Context, patchee *ComprehensiveCommentModel, patcher *ComprehensiveCommentModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ComprehensiveCommentModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Period" {
			patchee.Period = patcher.Period
			continue
		}
		if f == prefix+"ComprehensiveComment" {
			patchee.ComprehensiveComment = patcher.ComprehensiveComment
			continue
		}
		if f == prefix+"CommentUserId" {
			patchee.CommentUserId = patcher.CommentUserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListComprehensiveCommentModel executes a gorm list call
func DefaultListComprehensiveCommentModel(ctx context.Context, db *gorm.DB) ([]*ComprehensiveCommentModel, error) {
	in := ComprehensiveCommentModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ComprehensiveCommentModelORM{}, &ComprehensiveCommentModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ComprehensiveCommentModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ComprehensiveCommentModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ComprehensiveCommentModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ComprehensiveCommentModelORM) error
}
