package proto

import (
	context "context"
	fmt "fmt"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type AimModelORM struct {
	AchievementDifficultyBefore int64
	AchievementLevel            string
	AchievementWeight           int64
	AimItem                     string
	AimNumber                   int64
	CreatedAt                   *time.Time
	Id                          int64
	Period                      string
	UpdatedAt                   *time.Time
	UserId                      int64
}

// TableName overrides the default tablename generated by GORM
func (AimModelORM) TableName() string {
	return "aim_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AimModel) ToORM(ctx context.Context) (AimModelORM, error) {
	to := AimModelORM{}
	var err error
	if prehook, ok := interface{}(m).(AimModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.UserId = m.UserId
	to.AimItem = m.AimItem
	to.AchievementLevel = m.AchievementLevel
	to.AchievementWeight = m.AchievementWeight
	to.AchievementDifficultyBefore = m.AchievementDifficultyBefore
	to.AimNumber = m.AimNumber
	if m.CreatedAt != nil {
		*to.CreatedAt = m.CreatedAt.AsTime()
	}
	if m.UpdatedAt != nil {
		*to.UpdatedAt = m.UpdatedAt.AsTime()
	}
	if posthook, ok := interface{}(m).(AimModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AimModelORM) ToPB(ctx context.Context) (AimModel, error) {
	to := AimModel{}
	var err error
	if prehook, ok := interface{}(m).(AimModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.UserId = m.UserId
	to.AimItem = m.AimItem
	to.AchievementLevel = m.AchievementLevel
	to.AchievementWeight = m.AchievementWeight
	to.AchievementDifficultyBefore = m.AchievementDifficultyBefore
	to.AimNumber = m.AimNumber
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(AimModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AimModel the arg will be the target, the caller the one being converted from

// AimModelBeforeToORM called before default ToORM code
type AimModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *AimModelORM) error
}

// AimModelAfterToORM called after default ToORM code
type AimModelWithAfterToORM interface {
	AfterToORM(context.Context, *AimModelORM) error
}

// AimModelBeforeToPB called before default ToPB code
type AimModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *AimModel) error
}

// AimModelAfterToPB called after default ToPB code
type AimModelWithAfterToPB interface {
	AfterToPB(context.Context, *AimModel) error
}

type AchievementMeanModelORM struct {
	AchievementMean       string
	AchievementMeanNumber int64
	AimNumber             int64
	CreatedAt             *time.Time
	FifthMonth            bool
	FirstMonth            bool
	FourthMonth           bool
	Id                    int64
	Period                string
	SecondMonth           bool
	SixthMonth            bool
	ThirdMonth            bool
	UpdatedAt             *time.Time
	UserId                int64
}

// TableName overrides the default tablename generated by GORM
func (AchievementMeanModelORM) TableName() string {
	return "achievement_mean_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AchievementMeanModel) ToORM(ctx context.Context) (AchievementMeanModelORM, error) {
	to := AchievementMeanModelORM{}
	var err error
	if prehook, ok := interface{}(m).(AchievementMeanModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.UserId = m.UserId
	to.AimNumber = m.AimNumber
	to.AchievementMean = m.AchievementMean
	to.FirstMonth = m.FirstMonth
	to.SecondMonth = m.SecondMonth
	to.ThirdMonth = m.ThirdMonth
	to.FourthMonth = m.FourthMonth
	to.FifthMonth = m.FifthMonth
	to.SixthMonth = m.SixthMonth
	to.AchievementMeanNumber = m.AchievementMeanNumber
	if m.CreatedAt != nil {
		*to.CreatedAt = m.CreatedAt.AsTime()
	}
	if m.UpdatedAt != nil {
		*to.UpdatedAt = m.UpdatedAt.AsTime()
	}
	if posthook, ok := interface{}(m).(AchievementMeanModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AchievementMeanModelORM) ToPB(ctx context.Context) (AchievementMeanModel, error) {
	to := AchievementMeanModel{}
	var err error
	if prehook, ok := interface{}(m).(AchievementMeanModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.UserId = m.UserId
	to.AimNumber = m.AimNumber
	to.AchievementMean = m.AchievementMean
	to.FirstMonth = m.FirstMonth
	to.SecondMonth = m.SecondMonth
	to.ThirdMonth = m.ThirdMonth
	to.FourthMonth = m.FourthMonth
	to.FifthMonth = m.FifthMonth
	to.SixthMonth = m.SixthMonth
	to.AchievementMeanNumber = m.AchievementMeanNumber
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(AchievementMeanModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AchievementMeanModel the arg will be the target, the caller the one being converted from

// AchievementMeanModelBeforeToORM called before default ToORM code
type AchievementMeanModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *AchievementMeanModelORM) error
}

// AchievementMeanModelAfterToORM called after default ToORM code
type AchievementMeanModelWithAfterToORM interface {
	AfterToORM(context.Context, *AchievementMeanModelORM) error
}

// AchievementMeanModelBeforeToPB called before default ToPB code
type AchievementMeanModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *AchievementMeanModel) error
}

// AchievementMeanModelAfterToPB called after default ToPB code
type AchievementMeanModelWithAfterToPB interface {
	AfterToPB(context.Context, *AchievementMeanModel) error
}

type PersonalEvaModelORM struct {
	AchievementDifficulty int64
	AchievementRate       int64
	AimId                 int64
	Id                    int64
	PersonalEvaluation    string
}

// TableName overrides the default tablename generated by GORM
func (PersonalEvaModelORM) TableName() string {
	return "personal_eva_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PersonalEvaModel) ToORM(ctx context.Context) (PersonalEvaModelORM, error) {
	to := PersonalEvaModelORM{}
	var err error
	if prehook, ok := interface{}(m).(PersonalEvaModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AimId = m.AimId
	to.PersonalEvaluation = m.PersonalEvaluation
	to.AchievementRate = m.AchievementRate
	to.AchievementDifficulty = m.AchievementDifficulty
	if posthook, ok := interface{}(m).(PersonalEvaModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PersonalEvaModelORM) ToPB(ctx context.Context) (PersonalEvaModel, error) {
	to := PersonalEvaModel{}
	var err error
	if prehook, ok := interface{}(m).(PersonalEvaModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AimId = m.AimId
	to.PersonalEvaluation = m.PersonalEvaluation
	to.AchievementRate = m.AchievementRate
	to.AchievementDifficulty = m.AchievementDifficulty
	if posthook, ok := interface{}(m).(PersonalEvaModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PersonalEvaModel the arg will be the target, the caller the one being converted from

// PersonalEvaModelBeforeToORM called before default ToORM code
type PersonalEvaModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *PersonalEvaModelORM) error
}

// PersonalEvaModelAfterToORM called after default ToORM code
type PersonalEvaModelWithAfterToORM interface {
	AfterToORM(context.Context, *PersonalEvaModelORM) error
}

// PersonalEvaModelBeforeToPB called before default ToPB code
type PersonalEvaModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *PersonalEvaModel) error
}

// PersonalEvaModelAfterToPB called after default ToPB code
type PersonalEvaModelWithAfterToPB interface {
	AfterToPB(context.Context, *PersonalEvaModel) error
}

type EvaluationBeforeModelORM struct {
	AimId           int64
	Comment         string
	CommentUserId   int64
	EvaluatorNumber int64
	Id              int64
}

// TableName overrides the default tablename generated by GORM
func (EvaluationBeforeModelORM) TableName() string {
	return "evaluation_before_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *EvaluationBeforeModel) ToORM(ctx context.Context) (EvaluationBeforeModelORM, error) {
	to := EvaluationBeforeModelORM{}
	var err error
	if prehook, ok := interface{}(m).(EvaluationBeforeModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AimId = m.AimId
	to.Comment = m.Comment
	to.EvaluatorNumber = m.EvaluatorNumber
	to.CommentUserId = m.CommentUserId
	if posthook, ok := interface{}(m).(EvaluationBeforeModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EvaluationBeforeModelORM) ToPB(ctx context.Context) (EvaluationBeforeModel, error) {
	to := EvaluationBeforeModel{}
	var err error
	if prehook, ok := interface{}(m).(EvaluationBeforeModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AimId = m.AimId
	to.Comment = m.Comment
	to.EvaluatorNumber = m.EvaluatorNumber
	to.CommentUserId = m.CommentUserId
	if posthook, ok := interface{}(m).(EvaluationBeforeModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type EvaluationBeforeModel the arg will be the target, the caller the one being converted from

// EvaluationBeforeModelBeforeToORM called before default ToORM code
type EvaluationBeforeModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *EvaluationBeforeModelORM) error
}

// EvaluationBeforeModelAfterToORM called after default ToORM code
type EvaluationBeforeModelWithAfterToORM interface {
	AfterToORM(context.Context, *EvaluationBeforeModelORM) error
}

// EvaluationBeforeModelBeforeToPB called before default ToPB code
type EvaluationBeforeModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *EvaluationBeforeModel) error
}

// EvaluationBeforeModelAfterToPB called after default ToPB code
type EvaluationBeforeModelWithAfterToPB interface {
	AfterToPB(context.Context, *EvaluationBeforeModel) error
}

type EvaluationModelORM struct {
	AchievementDifficulty int64
	AchievementRate       int64
	AimId                 int64
	Comment               string
	EvaluatorNumber       int64
	EvaluatorUserId       int64
	Id                    int64
}

// TableName overrides the default tablename generated by GORM
func (EvaluationModelORM) TableName() string {
	return "evaluation_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *EvaluationModel) ToORM(ctx context.Context) (EvaluationModelORM, error) {
	to := EvaluationModelORM{}
	var err error
	if prehook, ok := interface{}(m).(EvaluationModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AimId = m.AimId
	to.Comment = m.Comment
	to.AchievementRate = m.AchievementRate
	to.AchievementDifficulty = m.AchievementDifficulty
	to.EvaluatorNumber = m.EvaluatorNumber
	to.EvaluatorUserId = m.EvaluatorUserId
	if posthook, ok := interface{}(m).(EvaluationModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EvaluationModelORM) ToPB(ctx context.Context) (EvaluationModel, error) {
	to := EvaluationModel{}
	var err error
	if prehook, ok := interface{}(m).(EvaluationModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AimId = m.AimId
	to.Comment = m.Comment
	to.AchievementRate = m.AchievementRate
	to.AchievementDifficulty = m.AchievementDifficulty
	to.EvaluatorNumber = m.EvaluatorNumber
	to.EvaluatorUserId = m.EvaluatorUserId
	if posthook, ok := interface{}(m).(EvaluationModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type EvaluationModel the arg will be the target, the caller the one being converted from

// EvaluationModelBeforeToORM called before default ToORM code
type EvaluationModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *EvaluationModelORM) error
}

// EvaluationModelAfterToORM called after default ToORM code
type EvaluationModelWithAfterToORM interface {
	AfterToORM(context.Context, *EvaluationModelORM) error
}

// EvaluationModelBeforeToPB called before default ToPB code
type EvaluationModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *EvaluationModel) error
}

// EvaluationModelAfterToPB called after default ToPB code
type EvaluationModelWithAfterToPB interface {
	AfterToPB(context.Context, *EvaluationModel) error
}

type ComprehensiveCommentModelORM struct {
	CommentUserId        int64
	ComprehensiveComment string
	Id                   int64
	Period               string
	UserId               int64
}

// TableName overrides the default tablename generated by GORM
func (ComprehensiveCommentModelORM) TableName() string {
	return "comprehensive_comment_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ComprehensiveCommentModel) ToORM(ctx context.Context) (ComprehensiveCommentModelORM, error) {
	to := ComprehensiveCommentModelORM{}
	var err error
	if prehook, ok := interface{}(m).(ComprehensiveCommentModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Period = m.Period
	to.ComprehensiveComment = m.ComprehensiveComment
	to.CommentUserId = m.CommentUserId
	if posthook, ok := interface{}(m).(ComprehensiveCommentModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ComprehensiveCommentModelORM) ToPB(ctx context.Context) (ComprehensiveCommentModel, error) {
	to := ComprehensiveCommentModel{}
	var err error
	if prehook, ok := interface{}(m).(ComprehensiveCommentModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Period = m.Period
	to.ComprehensiveComment = m.ComprehensiveComment
	to.CommentUserId = m.CommentUserId
	if posthook, ok := interface{}(m).(ComprehensiveCommentModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ComprehensiveCommentModel the arg will be the target, the caller the one being converted from

// ComprehensiveCommentModelBeforeToORM called before default ToORM code
type ComprehensiveCommentModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *ComprehensiveCommentModelORM) error
}

// ComprehensiveCommentModelAfterToORM called after default ToORM code
type ComprehensiveCommentModelWithAfterToORM interface {
	AfterToORM(context.Context, *ComprehensiveCommentModelORM) error
}

// ComprehensiveCommentModelBeforeToPB called before default ToPB code
type ComprehensiveCommentModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *ComprehensiveCommentModel) error
}

// ComprehensiveCommentModelAfterToPB called after default ToPB code
type ComprehensiveCommentModelWithAfterToPB interface {
	AfterToPB(context.Context, *ComprehensiveCommentModel) error
}

type UserModelORM struct {
	AdminFlg      bool
	AuthId        int64
	CreatedAt     *time.Time
	DepartmentId  int64
	EnrollmentFlg bool
	FirstName     string
	Id            int64
	JobId         int64
	LastName      string
	Period        string
	UpdatedAt     *time.Time
}

// TableName overrides the default tablename generated by GORM
func (UserModelORM) TableName() string {
	return "user_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserModel) ToORM(ctx context.Context) (UserModelORM, error) {
	to := UserModelORM{}
	var err error
	if prehook, ok := interface{}(m).(UserModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AuthId = m.AuthId
	to.Period = m.Period
	to.LastName = m.LastName
	to.FirstName = m.FirstName
	to.DepartmentId = m.DepartmentId
	to.JobId = m.JobId
	to.EnrollmentFlg = m.EnrollmentFlg
	to.AdminFlg = m.AdminFlg
	if m.CreatedAt != nil {
		*to.CreatedAt = m.CreatedAt.AsTime()
	}
	if m.UpdatedAt != nil {
		*to.UpdatedAt = m.UpdatedAt.AsTime()
	}
	if posthook, ok := interface{}(m).(UserModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserModelORM) ToPB(ctx context.Context) (UserModel, error) {
	to := UserModel{}
	var err error
	if prehook, ok := interface{}(m).(UserModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AuthId = m.AuthId
	to.Period = m.Period
	to.LastName = m.LastName
	to.FirstName = m.FirstName
	to.DepartmentId = m.DepartmentId
	to.JobId = m.JobId
	to.EnrollmentFlg = m.EnrollmentFlg
	to.AdminFlg = m.AdminFlg
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(UserModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserModel the arg will be the target, the caller the one being converted from

// UserModelBeforeToORM called before default ToORM code
type UserModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserModelORM) error
}

// UserModelAfterToORM called after default ToORM code
type UserModelWithAfterToORM interface {
	AfterToORM(context.Context, *UserModelORM) error
}

// UserModelBeforeToPB called before default ToPB code
type UserModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserModel) error
}

// UserModelAfterToPB called after default ToPB code
type UserModelWithAfterToPB interface {
	AfterToPB(context.Context, *UserModel) error
}

type PolicyModelORM struct {
	CreatedAt     *time.Time
	Id            int64
	MidTermPolicy string
	Period        string
	PeriodPolicy  string
	UpdatedAt     *time.Time
}

// TableName overrides the default tablename generated by GORM
func (PolicyModelORM) TableName() string {
	return "policy_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PolicyModel) ToORM(ctx context.Context) (PolicyModelORM, error) {
	to := PolicyModelORM{}
	var err error
	if prehook, ok := interface{}(m).(PolicyModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.MidTermPolicy = m.MidTermPolicy
	to.PeriodPolicy = m.PeriodPolicy
	if m.CreatedAt != nil {
		*to.CreatedAt = m.CreatedAt.AsTime()
	}
	if m.UpdatedAt != nil {
		*to.UpdatedAt = m.UpdatedAt.AsTime()
	}
	if posthook, ok := interface{}(m).(PolicyModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PolicyModelORM) ToPB(ctx context.Context) (PolicyModel, error) {
	to := PolicyModel{}
	var err error
	if prehook, ok := interface{}(m).(PolicyModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.MidTermPolicy = m.MidTermPolicy
	to.PeriodPolicy = m.PeriodPolicy
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(PolicyModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PolicyModel the arg will be the target, the caller the one being converted from

// PolicyModelBeforeToORM called before default ToORM code
type PolicyModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *PolicyModelORM) error
}

// PolicyModelAfterToORM called after default ToORM code
type PolicyModelWithAfterToORM interface {
	AfterToORM(context.Context, *PolicyModelORM) error
}

// PolicyModelBeforeToPB called before default ToPB code
type PolicyModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *PolicyModel) error
}

// PolicyModelAfterToPB called after default ToPB code
type PolicyModelWithAfterToPB interface {
	AfterToPB(context.Context, *PolicyModel) error
}

type DepartmentGoalModelORM struct {
	CreatedAt      *time.Time
	DepartmentGoal string
	DepartmentId   int64
	Id             int64
	Period         string
	UpdatedAt      *time.Time
}

// TableName overrides the default tablename generated by GORM
func (DepartmentGoalModelORM) TableName() string {
	return "department_goal_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DepartmentGoalModel) ToORM(ctx context.Context) (DepartmentGoalModelORM, error) {
	to := DepartmentGoalModelORM{}
	var err error
	if prehook, ok := interface{}(m).(DepartmentGoalModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.DepartmentId = m.DepartmentId
	to.DepartmentGoal = m.DepartmentGoal
	if m.CreatedAt != nil {
		*to.CreatedAt = m.CreatedAt.AsTime()
	}
	if m.UpdatedAt != nil {
		*to.UpdatedAt = m.UpdatedAt.AsTime()
	}
	if posthook, ok := interface{}(m).(DepartmentGoalModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DepartmentGoalModelORM) ToPB(ctx context.Context) (DepartmentGoalModel, error) {
	to := DepartmentGoalModel{}
	var err error
	if prehook, ok := interface{}(m).(DepartmentGoalModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.DepartmentId = m.DepartmentId
	to.DepartmentGoal = m.DepartmentGoal
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(DepartmentGoalModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DepartmentGoalModel the arg will be the target, the caller the one being converted from

// DepartmentGoalModelBeforeToORM called before default ToORM code
type DepartmentGoalModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *DepartmentGoalModelORM) error
}

// DepartmentGoalModelAfterToORM called after default ToORM code
type DepartmentGoalModelWithAfterToORM interface {
	AfterToORM(context.Context, *DepartmentGoalModelORM) error
}

// DepartmentGoalModelBeforeToPB called before default ToPB code
type DepartmentGoalModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *DepartmentGoalModel) error
}

// DepartmentGoalModelAfterToPB called after default ToPB code
type DepartmentGoalModelWithAfterToPB interface {
	AfterToPB(context.Context, *DepartmentGoalModel) error
}

type RoleModelORM struct {
	CreatedAt    *time.Time
	DepartmentId int64
	Id           int64
	JobId        int64
	Period       string
	Role         string
	UpdatedAt    *time.Time
}

// TableName overrides the default tablename generated by GORM
func (RoleModelORM) TableName() string {
	return "role_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *RoleModel) ToORM(ctx context.Context) (RoleModelORM, error) {
	to := RoleModelORM{}
	var err error
	if prehook, ok := interface{}(m).(RoleModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.DepartmentId = m.DepartmentId
	to.JobId = m.JobId
	to.Role = m.Role
	if m.CreatedAt != nil {
		*to.CreatedAt = m.CreatedAt.AsTime()
	}
	if m.UpdatedAt != nil {
		*to.UpdatedAt = m.UpdatedAt.AsTime()
	}
	if posthook, ok := interface{}(m).(RoleModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *RoleModelORM) ToPB(ctx context.Context) (RoleModel, error) {
	to := RoleModel{}
	var err error
	if prehook, ok := interface{}(m).(RoleModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Period = m.Period
	to.DepartmentId = m.DepartmentId
	to.JobId = m.JobId
	to.Role = m.Role
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(RoleModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type RoleModel the arg will be the target, the caller the one being converted from

// RoleModelBeforeToORM called before default ToORM code
type RoleModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *RoleModelORM) error
}

// RoleModelAfterToORM called after default ToORM code
type RoleModelWithAfterToORM interface {
	AfterToORM(context.Context, *RoleModelORM) error
}

// RoleModelBeforeToPB called before default ToPB code
type RoleModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *RoleModel) error
}

// RoleModelAfterToPB called after default ToPB code
type RoleModelWithAfterToPB interface {
	AfterToPB(context.Context, *RoleModel) error
}

// DefaultCreateAimModel executes a basic gorm create call
func DefaultCreateAimModel(ctx context.Context, in *AimModel, db *gorm.DB) (*AimModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AimModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAimModel(ctx context.Context, in *AimModel, db *gorm.DB) (*AimModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AimModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AimModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AimModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AimModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAimModel(ctx context.Context, in *AimModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AimModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AimModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAimModelSet(ctx context.Context, in []*AimModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AimModelORM{})).(AimModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AimModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AimModelORM{})).(AimModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AimModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AimModel, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AimModel, *gorm.DB) error
}

// DefaultStrictUpdateAimModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAimModel(ctx context.Context, in *AimModel, db *gorm.DB) (*AimModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAimModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AimModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AimModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAimModel executes a basic gorm update call with patch behavior
func DefaultPatchAimModel(ctx context.Context, in *AimModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*AimModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AimModel
	var err error
	if hook, ok := interface{}(&pbObj).(AimModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAimModel(ctx, &AimModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AimModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAimModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AimModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAimModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AimModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AimModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AimModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AimModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AimModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AimModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AimModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AimModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AimModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAimModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetAimModel(ctx context.Context, objects []*AimModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AimModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AimModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAimModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAimModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAimModel(ctx context.Context, patchee *AimModel, patcher *AimModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AimModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Period" {
			patchee.Period = patcher.Period
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"AimItem" {
			patchee.AimItem = patcher.AimItem
			continue
		}
		if f == prefix+"AchievementLevel" {
			patchee.AchievementLevel = patcher.AchievementLevel
			continue
		}
		if f == prefix+"AchievementWeight" {
			patchee.AchievementWeight = patcher.AchievementWeight
			continue
		}
		if f == prefix+"AchievementDifficultyBefore" {
			patchee.AchievementDifficultyBefore = patcher.AchievementDifficultyBefore
			continue
		}
		if f == prefix+"AimNumber" {
			patchee.AimNumber = patcher.AimNumber
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAimModel executes a gorm list call
func DefaultListAimModel(ctx context.Context, db *gorm.DB) ([]*AimModel, error) {
	in := AimModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AimModelORM{}, &AimModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AimModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AimModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AimModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AimModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AimModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AimModelORM) error
}

// DefaultCreateAchievementMeanModel executes a basic gorm create call
func DefaultCreateAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, db *gorm.DB) (*AchievementMeanModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AchievementMeanModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, db *gorm.DB) (*AchievementMeanModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AchievementMeanModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AchievementMeanModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AchievementMeanModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AchievementMeanModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AchievementMeanModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AchievementMeanModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAchievementMeanModelSet(ctx context.Context, in []*AchievementMeanModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AchievementMeanModelORM{})).(AchievementMeanModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AchievementMeanModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AchievementMeanModelORM{})).(AchievementMeanModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AchievementMeanModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AchievementMeanModel, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AchievementMeanModel, *gorm.DB) error
}

// DefaultStrictUpdateAchievementMeanModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, db *gorm.DB) (*AchievementMeanModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAchievementMeanModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AchievementMeanModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AchievementMeanModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAchievementMeanModel executes a basic gorm update call with patch behavior
func DefaultPatchAchievementMeanModel(ctx context.Context, in *AchievementMeanModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*AchievementMeanModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AchievementMeanModel
	var err error
	if hook, ok := interface{}(&pbObj).(AchievementMeanModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAchievementMeanModel(ctx, &AchievementMeanModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AchievementMeanModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAchievementMeanModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AchievementMeanModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAchievementMeanModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AchievementMeanModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AchievementMeanModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AchievementMeanModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AchievementMeanModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AchievementMeanModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AchievementMeanModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAchievementMeanModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetAchievementMeanModel(ctx context.Context, objects []*AchievementMeanModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AchievementMeanModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AchievementMeanModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAchievementMeanModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAchievementMeanModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAchievementMeanModel(ctx context.Context, patchee *AchievementMeanModel, patcher *AchievementMeanModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AchievementMeanModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Period" {
			patchee.Period = patcher.Period
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"AimNumber" {
			patchee.AimNumber = patcher.AimNumber
			continue
		}
		if f == prefix+"AchievementMean" {
			patchee.AchievementMean = patcher.AchievementMean
			continue
		}
		if f == prefix+"FirstMonth" {
			patchee.FirstMonth = patcher.FirstMonth
			continue
		}
		if f == prefix+"SecondMonth" {
			patchee.SecondMonth = patcher.SecondMonth
			continue
		}
		if f == prefix+"ThirdMonth" {
			patchee.ThirdMonth = patcher.ThirdMonth
			continue
		}
		if f == prefix+"FourthMonth" {
			patchee.FourthMonth = patcher.FourthMonth
			continue
		}
		if f == prefix+"FifthMonth" {
			patchee.FifthMonth = patcher.FifthMonth
			continue
		}
		if f == prefix+"SixthMonth" {
			patchee.SixthMonth = patcher.SixthMonth
			continue
		}
		if f == prefix+"AchievementMeanNumber" {
			patchee.AchievementMeanNumber = patcher.AchievementMeanNumber
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAchievementMeanModel executes a gorm list call
func DefaultListAchievementMeanModel(ctx context.Context, db *gorm.DB) ([]*AchievementMeanModel, error) {
	in := AchievementMeanModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AchievementMeanModelORM{}, &AchievementMeanModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AchievementMeanModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AchievementMeanModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AchievementMeanModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AchievementMeanModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AchievementMeanModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AchievementMeanModelORM) error
}

// DefaultCreatePersonalEvaModel executes a basic gorm create call
func DefaultCreatePersonalEvaModel(ctx context.Context, in *PersonalEvaModel, db *gorm.DB) (*PersonalEvaModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PersonalEvaModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPersonalEvaModel(ctx context.Context, in *PersonalEvaModel, db *gorm.DB) (*PersonalEvaModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PersonalEvaModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PersonalEvaModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PersonalEvaModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PersonalEvaModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePersonalEvaModel(ctx context.Context, in *PersonalEvaModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PersonalEvaModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PersonalEvaModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePersonalEvaModelSet(ctx context.Context, in []*PersonalEvaModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PersonalEvaModelORM{})).(PersonalEvaModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PersonalEvaModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PersonalEvaModelORM{})).(PersonalEvaModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PersonalEvaModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PersonalEvaModel, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PersonalEvaModel, *gorm.DB) error
}

// DefaultStrictUpdatePersonalEvaModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePersonalEvaModel(ctx context.Context, in *PersonalEvaModel, db *gorm.DB) (*PersonalEvaModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePersonalEvaModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PersonalEvaModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PersonalEvaModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPersonalEvaModel executes a basic gorm update call with patch behavior
func DefaultPatchPersonalEvaModel(ctx context.Context, in *PersonalEvaModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*PersonalEvaModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PersonalEvaModel
	var err error
	if hook, ok := interface{}(&pbObj).(PersonalEvaModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPersonalEvaModel(ctx, &PersonalEvaModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PersonalEvaModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPersonalEvaModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PersonalEvaModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePersonalEvaModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PersonalEvaModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PersonalEvaModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PersonalEvaModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PersonalEvaModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PersonalEvaModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PersonalEvaModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPersonalEvaModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetPersonalEvaModel(ctx context.Context, objects []*PersonalEvaModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PersonalEvaModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PersonalEvaModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPersonalEvaModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPersonalEvaModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPersonalEvaModel(ctx context.Context, patchee *PersonalEvaModel, patcher *PersonalEvaModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PersonalEvaModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AimId" {
			patchee.AimId = patcher.AimId
			continue
		}
		if f == prefix+"PersonalEvaluation" {
			patchee.PersonalEvaluation = patcher.PersonalEvaluation
			continue
		}
		if f == prefix+"AchievementRate" {
			patchee.AchievementRate = patcher.AchievementRate
			continue
		}
		if f == prefix+"AchievementDifficulty" {
			patchee.AchievementDifficulty = patcher.AchievementDifficulty
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPersonalEvaModel executes a gorm list call
func DefaultListPersonalEvaModel(ctx context.Context, db *gorm.DB) ([]*PersonalEvaModel, error) {
	in := PersonalEvaModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PersonalEvaModelORM{}, &PersonalEvaModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PersonalEvaModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalEvaModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PersonalEvaModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PersonalEvaModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalEvaModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PersonalEvaModelORM) error
}

// DefaultCreateEvaluationBeforeModel executes a basic gorm create call
func DefaultCreateEvaluationBeforeModel(ctx context.Context, in *EvaluationBeforeModel, db *gorm.DB) (*EvaluationBeforeModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EvaluationBeforeModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEvaluationBeforeModel(ctx context.Context, in *EvaluationBeforeModel, db *gorm.DB) (*EvaluationBeforeModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &EvaluationBeforeModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EvaluationBeforeModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EvaluationBeforeModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EvaluationBeforeModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEvaluationBeforeModel(ctx context.Context, in *EvaluationBeforeModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EvaluationBeforeModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EvaluationBeforeModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEvaluationBeforeModelSet(ctx context.Context, in []*EvaluationBeforeModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EvaluationBeforeModelORM{})).(EvaluationBeforeModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EvaluationBeforeModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EvaluationBeforeModelORM{})).(EvaluationBeforeModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EvaluationBeforeModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*EvaluationBeforeModel, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*EvaluationBeforeModel, *gorm.DB) error
}

// DefaultStrictUpdateEvaluationBeforeModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEvaluationBeforeModel(ctx context.Context, in *EvaluationBeforeModel, db *gorm.DB) (*EvaluationBeforeModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEvaluationBeforeModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EvaluationBeforeModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EvaluationBeforeModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEvaluationBeforeModel executes a basic gorm update call with patch behavior
func DefaultPatchEvaluationBeforeModel(ctx context.Context, in *EvaluationBeforeModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*EvaluationBeforeModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj EvaluationBeforeModel
	var err error
	if hook, ok := interface{}(&pbObj).(EvaluationBeforeModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEvaluationBeforeModel(ctx, &EvaluationBeforeModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EvaluationBeforeModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEvaluationBeforeModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EvaluationBeforeModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEvaluationBeforeModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EvaluationBeforeModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EvaluationBeforeModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *EvaluationBeforeModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *EvaluationBeforeModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *EvaluationBeforeModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *EvaluationBeforeModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEvaluationBeforeModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetEvaluationBeforeModel(ctx context.Context, objects []*EvaluationBeforeModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*EvaluationBeforeModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*EvaluationBeforeModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEvaluationBeforeModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEvaluationBeforeModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEvaluationBeforeModel(ctx context.Context, patchee *EvaluationBeforeModel, patcher *EvaluationBeforeModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*EvaluationBeforeModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AimId" {
			patchee.AimId = patcher.AimId
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"EvaluatorNumber" {
			patchee.EvaluatorNumber = patcher.EvaluatorNumber
			continue
		}
		if f == prefix+"CommentUserId" {
			patchee.CommentUserId = patcher.CommentUserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEvaluationBeforeModel executes a gorm list call
func DefaultListEvaluationBeforeModel(ctx context.Context, db *gorm.DB) ([]*EvaluationBeforeModel, error) {
	in := EvaluationBeforeModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &EvaluationBeforeModelORM{}, &EvaluationBeforeModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EvaluationBeforeModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationBeforeModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*EvaluationBeforeModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EvaluationBeforeModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationBeforeModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EvaluationBeforeModelORM) error
}

// DefaultCreateEvaluationModel executes a basic gorm create call
func DefaultCreateEvaluationModel(ctx context.Context, in *EvaluationModel, db *gorm.DB) (*EvaluationModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EvaluationModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEvaluationModel(ctx context.Context, in *EvaluationModel, db *gorm.DB) (*EvaluationModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &EvaluationModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EvaluationModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EvaluationModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EvaluationModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEvaluationModel(ctx context.Context, in *EvaluationModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EvaluationModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EvaluationModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEvaluationModelSet(ctx context.Context, in []*EvaluationModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EvaluationModelORM{})).(EvaluationModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EvaluationModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EvaluationModelORM{})).(EvaluationModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EvaluationModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*EvaluationModel, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*EvaluationModel, *gorm.DB) error
}

// DefaultStrictUpdateEvaluationModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEvaluationModel(ctx context.Context, in *EvaluationModel, db *gorm.DB) (*EvaluationModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEvaluationModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EvaluationModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EvaluationModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEvaluationModel executes a basic gorm update call with patch behavior
func DefaultPatchEvaluationModel(ctx context.Context, in *EvaluationModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*EvaluationModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj EvaluationModel
	var err error
	if hook, ok := interface{}(&pbObj).(EvaluationModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEvaluationModel(ctx, &EvaluationModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EvaluationModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEvaluationModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EvaluationModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEvaluationModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EvaluationModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EvaluationModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *EvaluationModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *EvaluationModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *EvaluationModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *EvaluationModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEvaluationModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetEvaluationModel(ctx context.Context, objects []*EvaluationModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*EvaluationModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*EvaluationModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEvaluationModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEvaluationModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEvaluationModel(ctx context.Context, patchee *EvaluationModel, patcher *EvaluationModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*EvaluationModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AimId" {
			patchee.AimId = patcher.AimId
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"AchievementRate" {
			patchee.AchievementRate = patcher.AchievementRate
			continue
		}
		if f == prefix+"AchievementDifficulty" {
			patchee.AchievementDifficulty = patcher.AchievementDifficulty
			continue
		}
		if f == prefix+"EvaluatorNumber" {
			patchee.EvaluatorNumber = patcher.EvaluatorNumber
			continue
		}
		if f == prefix+"EvaluatorUserId" {
			patchee.EvaluatorUserId = patcher.EvaluatorUserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEvaluationModel executes a gorm list call
func DefaultListEvaluationModel(ctx context.Context, db *gorm.DB) ([]*EvaluationModel, error) {
	in := EvaluationModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &EvaluationModelORM{}, &EvaluationModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EvaluationModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EvaluationModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*EvaluationModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EvaluationModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EvaluationModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EvaluationModelORM) error
}

// DefaultCreateComprehensiveCommentModel executes a basic gorm create call
func DefaultCreateComprehensiveCommentModel(ctx context.Context, in *ComprehensiveCommentModel, db *gorm.DB) (*ComprehensiveCommentModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ComprehensiveCommentModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadComprehensiveCommentModel(ctx context.Context, in *ComprehensiveCommentModel, db *gorm.DB) (*ComprehensiveCommentModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ComprehensiveCommentModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ComprehensiveCommentModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ComprehensiveCommentModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ComprehensiveCommentModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteComprehensiveCommentModel(ctx context.Context, in *ComprehensiveCommentModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ComprehensiveCommentModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ComprehensiveCommentModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteComprehensiveCommentModelSet(ctx context.Context, in []*ComprehensiveCommentModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ComprehensiveCommentModelORM{})).(ComprehensiveCommentModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ComprehensiveCommentModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ComprehensiveCommentModelORM{})).(ComprehensiveCommentModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ComprehensiveCommentModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ComprehensiveCommentModel, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ComprehensiveCommentModel, *gorm.DB) error
}

// DefaultStrictUpdateComprehensiveCommentModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateComprehensiveCommentModel(ctx context.Context, in *ComprehensiveCommentModel, db *gorm.DB) (*ComprehensiveCommentModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateComprehensiveCommentModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ComprehensiveCommentModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ComprehensiveCommentModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchComprehensiveCommentModel executes a basic gorm update call with patch behavior
func DefaultPatchComprehensiveCommentModel(ctx context.Context, in *ComprehensiveCommentModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*ComprehensiveCommentModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ComprehensiveCommentModel
	var err error
	if hook, ok := interface{}(&pbObj).(ComprehensiveCommentModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadComprehensiveCommentModel(ctx, &ComprehensiveCommentModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ComprehensiveCommentModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskComprehensiveCommentModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ComprehensiveCommentModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateComprehensiveCommentModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ComprehensiveCommentModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ComprehensiveCommentModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ComprehensiveCommentModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ComprehensiveCommentModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ComprehensiveCommentModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ComprehensiveCommentModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetComprehensiveCommentModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetComprehensiveCommentModel(ctx context.Context, objects []*ComprehensiveCommentModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ComprehensiveCommentModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ComprehensiveCommentModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchComprehensiveCommentModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskComprehensiveCommentModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskComprehensiveCommentModel(ctx context.Context, patchee *ComprehensiveCommentModel, patcher *ComprehensiveCommentModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ComprehensiveCommentModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Period" {
			patchee.Period = patcher.Period
			continue
		}
		if f == prefix+"ComprehensiveComment" {
			patchee.ComprehensiveComment = patcher.ComprehensiveComment
			continue
		}
		if f == prefix+"CommentUserId" {
			patchee.CommentUserId = patcher.CommentUserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListComprehensiveCommentModel executes a gorm list call
func DefaultListComprehensiveCommentModel(ctx context.Context, db *gorm.DB) ([]*ComprehensiveCommentModel, error) {
	in := ComprehensiveCommentModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ComprehensiveCommentModelORM{}, &ComprehensiveCommentModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ComprehensiveCommentModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ComprehensiveCommentModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ComprehensiveCommentModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ComprehensiveCommentModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ComprehensiveCommentModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ComprehensiveCommentModelORM) error
}

// DefaultCreateUserModel executes a basic gorm create call
func DefaultCreateUserModel(ctx context.Context, in *UserModel, db *gorm.DB) (*UserModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUserModel(ctx context.Context, in *UserModel, db *gorm.DB) (*UserModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUserModel(ctx context.Context, in *UserModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserModelSet(ctx context.Context, in []*UserModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserModelORM{})).(UserModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserModelORM{})).(UserModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UserModel, *gorm.DB) (*gorm.DB, error)
}
type UserModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UserModel, *gorm.DB) error
}

// DefaultStrictUpdateUserModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUserModel(ctx context.Context, in *UserModel, db *gorm.DB) (*UserModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUserModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUserModel executes a basic gorm update call with patch behavior
func DefaultPatchUserModel(ctx context.Context, in *UserModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*UserModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UserModel
	var err error
	if hook, ok := interface{}(&pbObj).(UserModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUserModel(ctx, &UserModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUserModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUserModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UserModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UserModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UserModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UserModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUserModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetUserModel(ctx context.Context, objects []*UserModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UserModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UserModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUserModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUserModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserModel(ctx context.Context, patchee *UserModel, patcher *UserModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UserModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AuthId" {
			patchee.AuthId = patcher.AuthId
			continue
		}
		if f == prefix+"Period" {
			patchee.Period = patcher.Period
			continue
		}
		if f == prefix+"LastName" {
			patchee.LastName = patcher.LastName
			continue
		}
		if f == prefix+"FirstName" {
			patchee.FirstName = patcher.FirstName
			continue
		}
		if f == prefix+"DepartmentId" {
			patchee.DepartmentId = patcher.DepartmentId
			continue
		}
		if f == prefix+"JobId" {
			patchee.JobId = patcher.JobId
			continue
		}
		if f == prefix+"EnrollmentFlg" {
			patchee.EnrollmentFlg = patcher.EnrollmentFlg
			continue
		}
		if f == prefix+"AdminFlg" {
			patchee.AdminFlg = patcher.AdminFlg
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserModel executes a gorm list call
func DefaultListUserModel(ctx context.Context, db *gorm.DB) ([]*UserModel, error) {
	in := UserModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserModelORM{}, &UserModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserModelORM) error
}

// DefaultCreatePolicyModel executes a basic gorm create call
func DefaultCreatePolicyModel(ctx context.Context, in *PolicyModel, db *gorm.DB) (*PolicyModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PolicyModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PolicyModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PolicyModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PolicyModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPolicyModel(ctx context.Context, in *PolicyModel, db *gorm.DB) (*PolicyModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PolicyModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PolicyModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PolicyModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PolicyModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PolicyModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PolicyModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PolicyModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PolicyModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePolicyModel(ctx context.Context, in *PolicyModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PolicyModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PolicyModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PolicyModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PolicyModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PolicyModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePolicyModelSet(ctx context.Context, in []*PolicyModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PolicyModelORM{})).(PolicyModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PolicyModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PolicyModelORM{})).(PolicyModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PolicyModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PolicyModel, *gorm.DB) (*gorm.DB, error)
}
type PolicyModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PolicyModel, *gorm.DB) error
}

// DefaultStrictUpdatePolicyModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePolicyModel(ctx context.Context, in *PolicyModel, db *gorm.DB) (*PolicyModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePolicyModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PolicyModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PolicyModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PolicyModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PolicyModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PolicyModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PolicyModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PolicyModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPolicyModel executes a basic gorm update call with patch behavior
func DefaultPatchPolicyModel(ctx context.Context, in *PolicyModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*PolicyModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PolicyModel
	var err error
	if hook, ok := interface{}(&pbObj).(PolicyModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPolicyModel(ctx, &PolicyModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PolicyModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPolicyModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PolicyModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePolicyModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PolicyModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PolicyModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PolicyModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PolicyModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PolicyModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PolicyModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PolicyModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PolicyModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PolicyModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPolicyModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetPolicyModel(ctx context.Context, objects []*PolicyModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PolicyModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PolicyModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPolicyModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPolicyModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPolicyModel(ctx context.Context, patchee *PolicyModel, patcher *PolicyModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PolicyModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Period" {
			patchee.Period = patcher.Period
			continue
		}
		if f == prefix+"MidTermPolicy" {
			patchee.MidTermPolicy = patcher.MidTermPolicy
			continue
		}
		if f == prefix+"PeriodPolicy" {
			patchee.PeriodPolicy = patcher.PeriodPolicy
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPolicyModel executes a gorm list call
func DefaultListPolicyModel(ctx context.Context, db *gorm.DB) ([]*PolicyModel, error) {
	in := PolicyModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PolicyModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PolicyModelORM{}, &PolicyModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PolicyModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PolicyModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PolicyModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PolicyModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PolicyModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PolicyModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PolicyModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PolicyModelORM) error
}

// DefaultCreateDepartmentGoalModel executes a basic gorm create call
func DefaultCreateDepartmentGoalModel(ctx context.Context, in *DepartmentGoalModel, db *gorm.DB) (*DepartmentGoalModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepartmentGoalModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepartmentGoalModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DepartmentGoalModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepartmentGoalModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDepartmentGoalModel(ctx context.Context, in *DepartmentGoalModel, db *gorm.DB) (*DepartmentGoalModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DepartmentGoalModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &DepartmentGoalModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepartmentGoalModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DepartmentGoalModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DepartmentGoalModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DepartmentGoalModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepartmentGoalModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepartmentGoalModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDepartmentGoalModel(ctx context.Context, in *DepartmentGoalModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DepartmentGoalModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DepartmentGoalModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DepartmentGoalModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DepartmentGoalModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepartmentGoalModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteDepartmentGoalModelSet(ctx context.Context, in []*DepartmentGoalModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DepartmentGoalModelORM{})).(DepartmentGoalModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DepartmentGoalModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DepartmentGoalModelORM{})).(DepartmentGoalModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DepartmentGoalModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*DepartmentGoalModel, *gorm.DB) (*gorm.DB, error)
}
type DepartmentGoalModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*DepartmentGoalModel, *gorm.DB) error
}

// DefaultStrictUpdateDepartmentGoalModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDepartmentGoalModel(ctx context.Context, in *DepartmentGoalModel, db *gorm.DB) (*DepartmentGoalModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDepartmentGoalModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DepartmentGoalModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DepartmentGoalModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DepartmentGoalModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepartmentGoalModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DepartmentGoalModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepartmentGoalModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepartmentGoalModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchDepartmentGoalModel executes a basic gorm update call with patch behavior
func DefaultPatchDepartmentGoalModel(ctx context.Context, in *DepartmentGoalModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*DepartmentGoalModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj DepartmentGoalModel
	var err error
	if hook, ok := interface{}(&pbObj).(DepartmentGoalModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDepartmentGoalModel(ctx, &DepartmentGoalModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DepartmentGoalModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDepartmentGoalModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DepartmentGoalModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDepartmentGoalModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DepartmentGoalModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DepartmentGoalModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *DepartmentGoalModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DepartmentGoalModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *DepartmentGoalModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DepartmentGoalModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *DepartmentGoalModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DepartmentGoalModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *DepartmentGoalModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetDepartmentGoalModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetDepartmentGoalModel(ctx context.Context, objects []*DepartmentGoalModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*DepartmentGoalModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*DepartmentGoalModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDepartmentGoalModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDepartmentGoalModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDepartmentGoalModel(ctx context.Context, patchee *DepartmentGoalModel, patcher *DepartmentGoalModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*DepartmentGoalModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Period" {
			patchee.Period = patcher.Period
			continue
		}
		if f == prefix+"DepartmentId" {
			patchee.DepartmentId = patcher.DepartmentId
			continue
		}
		if f == prefix+"DepartmentGoal" {
			patchee.DepartmentGoal = patcher.DepartmentGoal
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDepartmentGoalModel executes a gorm list call
func DefaultListDepartmentGoalModel(ctx context.Context, db *gorm.DB) ([]*DepartmentGoalModel, error) {
	in := DepartmentGoalModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepartmentGoalModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &DepartmentGoalModelORM{}, &DepartmentGoalModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepartmentGoalModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DepartmentGoalModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepartmentGoalModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DepartmentGoalModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DepartmentGoalModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepartmentGoalModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepartmentGoalModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DepartmentGoalModelORM) error
}

// DefaultCreateRoleModel executes a basic gorm create call
func DefaultCreateRoleModel(ctx context.Context, in *RoleModel, db *gorm.DB) (*RoleModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type RoleModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadRoleModel(ctx context.Context, in *RoleModel, db *gorm.DB) (*RoleModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(RoleModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &RoleModelORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := RoleModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(RoleModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type RoleModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteRoleModel(ctx context.Context, in *RoleModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(RoleModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&RoleModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(RoleModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type RoleModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteRoleModelSet(ctx context.Context, in []*RoleModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&RoleModelORM{})).(RoleModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&RoleModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&RoleModelORM{})).(RoleModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type RoleModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*RoleModel, *gorm.DB) (*gorm.DB, error)
}
type RoleModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*RoleModel, *gorm.DB) error
}

// DefaultStrictUpdateRoleModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateRoleModel(ctx context.Context, in *RoleModel, db *gorm.DB) (*RoleModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateRoleModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &RoleModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(RoleModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(RoleModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type RoleModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchRoleModel executes a basic gorm update call with patch behavior
func DefaultPatchRoleModel(ctx context.Context, in *RoleModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*RoleModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj RoleModel
	var err error
	if hook, ok := interface{}(&pbObj).(RoleModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadRoleModel(ctx, &RoleModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(RoleModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskRoleModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(RoleModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateRoleModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(RoleModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type RoleModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *RoleModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type RoleModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *RoleModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type RoleModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *RoleModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type RoleModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *RoleModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetRoleModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetRoleModel(ctx context.Context, objects []*RoleModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*RoleModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*RoleModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchRoleModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskRoleModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskRoleModel(ctx context.Context, patchee *RoleModel, patcher *RoleModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*RoleModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Period" {
			patchee.Period = patcher.Period
			continue
		}
		if f == prefix+"DepartmentId" {
			patchee.DepartmentId = patcher.DepartmentId
			continue
		}
		if f == prefix+"JobId" {
			patchee.JobId = patcher.JobId
			continue
		}
		if f == prefix+"Role" {
			patchee.Role = patcher.Role
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamp.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListRoleModel executes a gorm list call
func DefaultListRoleModel(ctx context.Context, db *gorm.DB) ([]*RoleModel, error) {
	in := RoleModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &RoleModelORM{}, &RoleModel{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []RoleModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*RoleModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type RoleModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]RoleModelORM) error
}
